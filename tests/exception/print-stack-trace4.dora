//= output "Exception: SubException 0\n0: SubException.SubException(String, Int): 13\n1: create_exceptions() -> SubException: 8\n2: main(): 4\nException: SubException 1\n0: create_exceptions() -> SubException: 8\n1: main(): 4\n"

fun main() {
  create_exceptions().printTraces();
}

fun create_exceptions() -> SubException {
  return SubException("SubException", 1);
}

class SubException(msg: String, t: Int) : Exception(msg + " " + t.toString()) {
  var exception: Option[SubException] = if t > 0 {
    some[SubException](SubException(msg, t-1))
  } else {
    none[SubException]()
  };

  // currently needed, because of error when an @abstract function is overloaded in base class
  @override fun printStackTrace() {
    super.printStackTrace();
  }

  fun printTraces() {
    if(self.exception.isPresent) {
      self.exception.value.printTraces();
    }
    self.printStackTrace();
  }
}