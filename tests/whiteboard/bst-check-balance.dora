class Node(let val: Int, var left: Option[Node], var right: Option[Node]) {
  @static fun val(val: Int) -> Node = Node(val, none[Node](), none[Node]());
}

fun main() {
  let root = Node(5,
                  some[Node](Node(10,
                       some[Node](Node::val(20)),
                       some[Node](Node::val(25)))),
                  some[Node](Node(15,
                       some[Node](Node::val(30)),
                       some[Node](Node::val(35)))));

  dumpTree(some[Node](root), 0);
  println(isBalanced(root).toString());

  root.right.value.right.value.right = some[Node](Node(40, none[Node](), some[Node](Node::val(45))));

  dumpTree(some[Node](root), 0);
  println(isBalanced(root).toString());
}

fun dumpTree(root: Option[Node], depth: Int) {
  if root.isEmpty() {
    if depth == 0 {
      println("nil");
    }

    return;
  }

  dumpTree(root.value.right, depth+1);

  var i = 0;

  while i < depth {
    print("\t");
    i = i + 1;
  }

  println(root.value.val.toString());

  dumpTree(root.value.left, depth+1);
}

fun isBalanced(root: Node) -> Bool {
  return height(some[Node](root)) >= 0;
}

fun height(node: Option[Node]) -> Int {
  if node.isEmpty() {
    return 0;
  }

  let l = height(node.value.left);
  let r = height(node.value.right);

  let diff = (l - r).abs();

  if diff > 1 {
    return -1;
  } else {
    return max(l, r) + 1;
  }
}

fun max(left: Int, right: Int) -> Int {
  if left >= right {
    return left;
  } else {
    return right;
  }
}
