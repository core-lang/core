/**
 * An instantaneous point on the time-line.
 *
 * This class models a single instantaneous point on the time-line. This might be used to record
 * event time-stamps in the application.
 *
 * For practicality, the instant is stored with some constraints. The measurable time-line is
 * restricted to the number of seconds that can be held in a {@code long}. This is greater than the
 * current estimated age of the universe. The instant is stored to nanosecond resolution.
 *
 * The range of an instant requires the storage of a number larger than a {@code long}. To achieve
 * this, the class stores a {@code long} representing epoch-seconds and an {@code int} representing
 * nanosecond-of-second, which will always be between 0 and 999,999,999. The epoch-seconds are
 * measured from the standard Java epoch of {@code 1970-01-01T00:00:00Z} where instants after the
 * epoch have positive values, and earlier instants have negative values. For both the epoch-second
 * and nanosecond parts, a larger value is always later on the time-line than a smaller value.
 *
 * <h3>Time-scale</h3>
 *
 * The length of the solar day is the standard way that humans measure time. This has traditionally
 * been subdivided into 24 hours of 60 minutes of 60 seconds, forming a 86400 second day.
 *
 * Modern timekeeping is based on atomic clocks which precisely define an SI second relative to the
 * transitions of a Caesium atom. The length of an SI second was defined to be very close to the
 * 86400th fraction of a day.
 *
 * Unfortunately, as the Earth rotates the length of the day varies. In addition, over time the
 * average length of the day is getting longer as the Earth slows. As a result, the length of a
 * solar day in 2012 is slightly longer than 86400 SI seconds. The actual length of any given day
 * and the amount by which the Earth is slowing are not predictable and can only be determined by
 * measurement. The UT1 time-scale captures the accurate length of day, but is only available some
 * time after the day has completed.
 *
 * The UTC time-scale is a standard approach to bundle up all the additional fractions of a second
 * from UT1 into whole seconds, known as <i>leap-seconds</i>. A leap-second may be added or removed
 * depending on the Earth's rotational changes. As such, UTC permits a day to have 86399 SI seconds
 * or 86401 SI seconds where necessary in order to keep the day aligned with the Sun.
 *
 * The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.
 * Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and
 * alterations to the length of the notional second. As of 2012, discussions are underway to change
 * the definition of UTC again, with the potential to remove leap seconds or introduce other
 * changes.
 *
 * Given the complexity of accurate timekeeping described above, this Java API defines its own
 * time-scale with a simplification. The Java time-scale is defined as follows: <ul> <li>midday will
 * always be exactly as defined by the agreed international civil time</li> <li>other times during
 * the day will be broadly in line with the agreed international civil time</li> <li>the day will be
 * divided into exactly 86400 subdivisions, referred to as "seconds"</li> <li>the Java "second" may
 * differ from an SI second</li> </ul><p> Agreed international civil time is the base time-scale
 * agreed by international convention, which in 2012 is UTC (with leap-seconds).
 *
 * In 2012, the definition of the Java time-scale is the same as UTC for all days except those where
 * a leap-second occurs. On days where a leap-second does occur, the time-scale effectively
 * eliminates the leap-second, maintaining the fiction of 86400 seconds in the day.
 *
 * The main benefit of always dividing the day into 86400 subdivisions is that it matches the
 * expectations of most users of the API. The alternative is to force every user to understand what
 * a leap second is and to force them to have special logic to handle them. Most applications do not
 * have access to a clock that is accurate enough to record leap-seconds. Most applications also do
 * not have a problem with a second being a very small amount longer or shorter than a real SI
 * second during a leap-second.
 *
 * If an application does have access to an accurate clock that reports leap-seconds, then the
 * recommended technique to implement the Java time-scale is to use the UTC-SLS convention. <a
 * href="http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/">UTC-SLS</a> effectively smoothes the
 * leap-second over the last 1000 seconds of the day, making each of the last 1000 "seconds"
 * 1/1000th longer or shorter than a real SI second.
 *
 * One final problem is the definition of the agreed international civil time before the
 * introduction of modern UTC in 1972. This includes the Java epoch of {@code 1970-01-01}. It is
 * intended that instants before 1972 be interpreted based on the solar day divided into 86400
 * subdivisions.
 *
 * The Java time-scale is used by all date-time classes. This includes {@code Instant}, {@code
 * LocalDate}, {@code LocalTime}, {@code OffsetDateTime}, {@code ZonedDateTime} and {@code
 * Duration}.
 *
 * <h3>Specification for implementors</h3> This class is immutable and thread-safe.
 *
 * Constructs an instance of {@code Instant} using seconds from the epoch of 1970-01-01T00:00:00Z
 * and nanosecond fraction of second.
 *
 * @param seconds
 *   the number of seconds from 1970-01-01T00:00:00Z
 * @param nanos
 *   the nanoseconds within the second, must be positive and never exceed 999,999,999
 */
@pub class Instant(let seconds: Int64, let nanos: Int32) {
  @pub fun equals(rhs: Instant): Bool = self.seconds == rhs.seconds && self.nanos == rhs.nanos;

  @pub @static /*let*/ fun EPOCH(): Instant = Instant(0L, 0);
}

impl Equals for Instant {
  fun equals(other: Instant): Bool = self == other;
}
