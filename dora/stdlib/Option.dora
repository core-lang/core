@pub enum Option[T] {
  Some(T),
  None,
}

import Option::Some;
import Option::None;

impl[T] Option[T] {
  @pub fun isNone(): Bool {
    match self {
      Some(_) => false,
      None => true,
    }
  }

  @pub fun isSome(): Bool {
    match self {
      Some(_) => true,
      None => false,
    }
  }

  @pub fun getOrPanic(): T {
    match self {
      Some(value) => value,
      None => {
        fatalError("cannot unwrap None.");
        unreachable[T]()
      }
    }
  }

  fun unwrapNone() {
    match self {
      Some(_) => {
        fatalError("cannot unwrap Some.");
      },
      None => (),
    }
  }

  @pub fun unwrapOr(alt: T): T {
    match self {
      Some(value) => value,
      None => alt,
    }
  }

  @pub fun has(val: T): Bool {
    match self {
      Some(actual) => actual === val,
      None => false,
    }
  }

  @pub fun or(alt: Option[T]): Option[T] {
    if self.isSome() {
      return self;
    } else {
      return alt;
    }
  }
}

impl[T: Default] Option[T] {
  @pub fun getOrDefault(): T {
    match self {
      Some(actual) => actual,
      None => T::default(),
    }
  }
}

impl[T: Zero] Option[T] {
  @pub fun getOrZero(): T {
    match self {
      Some(actual) => actual,
      None => T::zero(),
    }
  }
}

impl[T: Equals] Option[T] {
  @pub fun contains(rhs: T): Bool {
    if self.isSome() {
      let lhs = self.getOrPanic();
      lhs.equals(rhs)
    } else {
      false
    }
  }

  @pub fun equals(rhs: Option[T]): Bool {
    if self.isSome() {
      if rhs.isSome() {
        let lhs = self.getOrPanic();
        let rhs = rhs.getOrPanic();
        lhs.equals(rhs)
      } else {
        false
      }
    } else {
      rhs.isNone()
    }
  }
}

impl[T: Stringable] Option[T] {
  @pub fun toString(): String {
    match self {
      Some(value) => "Some(${value})",
      None => "None",
    }
  }
}
