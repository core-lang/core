@open @abstract class Node {
    var birthday: Int;
    var value: Int;
    var left: Option[Node];
    var right: Option[Node];

    @static fun splay(var tree: Option[Node], node: Node) -> Option[Node] {
        if tree.isEmpty() {
            return none[Node]();
        }

        node.left = none[Node]();
        node.right = none[Node]();

        var l: Node = node;
        var r: Node = node;

        loop {
            if node.value <= tree.value.value {
                if tree.value.left.isEmpty() {
                    break;
                }

                if node.value <= tree.value.left.value.value {
                    // rotate right
                    let y = tree.value.left;
                    tree.value.left = y.value.right;
                    y.value.right = tree;
                    tree = y;
                    if tree.value.left.isEmpty() {
                        break;
                    }
                }

                // link right
                r.left = tree;
                r = tree.value;
                tree = tree.value.left;

            } else if node.value > tree.value.value {
                if tree.value.right.isEmpty() {
                    break;
                }

                if node.value > tree.value.right.value.value {
                    // rotate left
                    let y = tree.value.right;
                    tree.value.right = y.value.left;
                    y.value.left = tree;
                    tree = y;
                    if tree.value.right.isEmpty() {
                        break;
                    }
                }

                // link left
                l.right = tree;
                l = tree.value;
                tree = tree.value.right;

            } else {
                break;
            }
        }

        l.right = tree.value.left;
        r.left = tree.value.right;
        tree.value.left = node.right;
        tree.value.right = node.left;
        return tree;
    }

    @static fun insert(var tree: Option[Node], node: Node) -> Node {
        if tree.isEmpty() {
            return node;
        }

        tree = Node::splay(tree, node);

        if node.value <= tree.value.value {
            node.left = tree.value.left;
            node.right = tree;
            tree.value.left = none[Node]();
        } else { // if (node.value > true.value)
            node.right = tree.value.right;
            node.left = tree;
            tree.value.right = none[Node]();
        }

        return node;
    }

    @static fun trunc(date: Int, optTree: Option[Node], depth: Int) {
        if optTree.isEmpty() {
            return;
        }

        let tree = optTree.value;

        if tree.left.isPresent {
            if depth == 0 {
                /*if tree.left !== nil {
                    println("truncate left");
                }*/
                tree.left = none[Node]();
            } else {
                Node::trunc(date, tree.left, depth-1);
            }
        }

        if tree.right.isPresent {
            if depth == 0 {
                /*if tree.right !== nil {
                    println("truncate right");
                }*/
                tree.right = none[Node]();
            } else {
                Node::trunc(date, tree.right, depth-1);
            }
        }
    }

    fun printAge(date: Int) {
        println((date - self.birthday).toString());
    }

    fun printAges(date: Int) {
        self.printAge(date);

        if self.left.isPresent {
            self.left.value.printAges(date);
        }

        if self.right.isPresent {
            self.right.value.printAges(date);
        }
    }

    fun printTree(date: Int, prefix: String) {
        print(prefix);
        print("age: " + (date - self.birthday).toString());
        println(" value: " + self.value.toString());

        if self.left.isPresent {
            self.left.value.printTree(date, prefix + "  ");
        }

        if self.right.isPresent {
            self.right.value.printTree(date, prefix + "  ");
        }
    }

    @static fun countNodes(node: Option[Node]) -> Int {
        if node.isEmpty() {
            return 0;
        }

        return 1 + Node::countNodes(node.value.left) + Node::countNodes(node.value.right);
    }
}

class NodeA: Node {}
class NodeB: Node { let x1: Long = 0L; }
class NodeC: Node { let x1: Long = 0L; let x2: Long = 0L; }
class NodeD: Node { let x1: Double = 0.0; let x2: Double = 0.0; let x3: Double = 0.0; }

class Node40: Node {}
class Node48: Node { let x1: Long = 0L; }
class Node56: Node { let x1: Long = 0L; let x2: Long = 0L; }
class Node64: Node { let x1: Long = 0L; let x2: Long = 0L; let x3: Long = 0L; }
class Node72: Node { let x1: Long = 0L; let x2: Long = 0L; let x3: Long = 0L; let x4: Long = 0L; }
class Node80: Node { let x1: Long = 0L; let x2: Long = 0L; let x3: Long = 0L; let x4: Long = 0L; let x5: Long = 0L; }

fun main() {
    if argc() < 4 {
        println("usage: splunc <seed> <max-size> <iterations> <trunc-depth> [<iterations> <trunc-depth>]");
        exit(1);
    }

    let rnd = Random(argv(0).parseLong());
    let max_size = argv(1).parseInt();
    var date = 0;

    var tree: Node = NodeA();
    tree.birthday = date;
    date = date + 1;
    tree.value = rnd.nextIntWithBound(max_size);

    var j = 2;

    while j + 2 <= argc() {
        let n = argv(j).parseInt();
        let depth = argv(j+1).parseInt();

        // println("n = " + n.toString());
        // println("depth = " + depth.toString());

        var i = 0;
        while i < n {
            let value = rnd.nextIntWithBound(4);
            var node: Option[Node] = none[Node]();

            if value == 0 {
                node = some[Node](NodeA());
            } else if value == 1 {
                node = some[Node](NodeB());
            } else if value == 2 {
                node = some[Node](NodeC());
            } else {
                assert(value == 3);
                node = some[Node](NodeD());
            }

            node.value.birthday = date;
            date = date + 1;
            node.value.value = rnd.nextIntWithBound(max_size);

            tree = Node::insert(some[Node](tree), node.value);
            Node::trunc(date, some[Node](tree), depth);

            // println("nodes in tree: " + Node::countNodes(tree).toString());

            i = i + 1;
        }

        j = j + 2;
    }
}
