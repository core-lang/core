fun main() {
  var maxDepth = 6;

  if argc() > 0 {
    maxDepth = argv(0).parseInt();
  }

  if 6 > maxDepth {
    maxDepth = 6;
  }

  let stretchDepth = maxDepth + 1;
  println("stretch tree of depth " + stretchDepth.toString() +
          "\t check: " + checkTree(some[TreeNode](createTree(stretchDepth))).toString());

  trees(maxDepth);
}

fun trees(maxDepth: Int) {
  let longLastingNode = createTree(maxDepth);
  var depth = 4;

  while depth <= maxDepth {
    let iterations = 16 << (maxDepth - depth);

    loops(iterations, depth);
    depth = depth + 2;
  }

  println("long lived tree of depth " + maxDepth.toString()
    + "\t check: " + checkTree(some[TreeNode](longLastingNode)).toString());
}

fun loops(iterations: Int, depth: Int) {
  var check = 0;
  var item = 0;

  while item < iterations {
    check = check + checkTree(some[TreeNode](createTree(depth)));
    item = item + 1;
  }

  println(iterations.toString() + "\t trees of depth " +
    depth.toString() + "\t check: " + check.toString());
}

fun createTree(var depth: Int) -> TreeNode {
  let node = TreeNode(0, none[TreeNode](), none[TreeNode]());

  if depth > 0 {
    depth = depth - 1;
    node.left = some[TreeNode](createTree(depth));
    node.right = some[TreeNode](createTree(depth));
  }

  return node;
}

fun checkTree(node: Option[TreeNode]) -> Int {
  if node.isNone() {
    return 1;
  }
  if node.unwrap().left.isNone() {
    return 1;
  }

  return checkTree(node.unwrap().left) + checkTree(node.unwrap().right) + 1;
}

class TreeNode(let item: Int, var left: Option[TreeNode], var right: Option[TreeNode])
