intrinsic fun fatalError(msg: Str);
intrinsic fun abort();
intrinsic fun exit(status: int);
fun unreachable() {
  fatalError("unreachable code");
}

fun unimplemented() {
  fatalError("not yet implemented");
}

intrinsic fun print(text: Str);
intrinsic fun println(text: Str);
intrinsic fun addressOf(object: Object) -> long;
intrinsic fun assert(val: bool);
intrinsic fun debug();
intrinsic fun argc() -> int;
intrinsic fun argv(idx: int) -> Str;
intrinsic fun forceCollect();
intrinsic fun forceMinorCollect();

intrinsic fun call(fct: Str);
intrinsic fun throwFromNative(val: bool) throws;
intrinsic fun throwFromNativeButNotThrows(val: bool);

intrinsic fun timestamp() -> long;

intrinsic class bool {
  intrinsic fun toInt() -> int;
  fun toString() -> Str {
    if self {
      return "true";
    } else {
      return "false";
    }
  }

  intrinsic fun equals(rhs: bool) -> bool;
  intrinsic fun not() -> bool;
}

intrinsic class byte {
  intrinsic fun toInt() -> int;
  intrinsic fun toLong() -> long;
  intrinsic fun toString() -> Str;

  intrinsic fun equals(rhs: byte) -> bool;
  intrinsic fun compareTo(rhs: byte) -> int;
}

intrinsic class char {
  intrinsic fun toInt() -> int;
  intrinsic fun toLong() -> long;
  intrinsic fun toString() -> Str;

  intrinsic fun equals(rhs: char) -> bool;
  intrinsic fun compareTo(rhs: char) -> int;

  fun encodeUtf8(bytes: Array<byte>, offset: int) {
    let val = self.toInt();

    if val < 0x80 {
      bytes[offset] = val.toByte();
    } else if val < 0x800 {
      bytes[offset] = (0xC0 | ((val >> 6) & 0x1F)).toByte();
      bytes[offset+1] = (0x80 | (val & 0x3F)).toByte();
    } else if val < 0x10000 {
      bytes[offset] = (0xE0 | ((val >> 12) & 0x0F)).toByte();
      bytes[offset+1] = (0x80 | ((val >> 6) & 0x3F)).toByte();
      bytes[offset+2] = (0x80 | (val & 0x3F)).toByte();
    } else {
      bytes[offset] = (0xF0 | ((val >> 18) & 0x07)).toByte();
      bytes[offset+1] = (0x80 | ((val >> 12) & 0x3F)).toByte();
      bytes[offset+2] = (0x80 | ((val >> 6) & 0x3F)).toByte();
      bytes[offset+3] = (0x80 | (val & 0x3F)).toByte();
    }
  }

  fun lenUtf8() -> int {
    let val = self.toInt();

    if val < 0x80 {
      return 1;
    } else if val < 0x800 {
      return 2;
    } else if val < 0x10000 {
      return 3;
    } else {
      return 4;
    }
  }
}

intrinsic class int {
  intrinsic fun toByte() -> byte;
  fun toChar() throws -> char {
    if self >= 0 && self <= 0x10FFFF && (self < 0xD800 || self > 0xDFFF) {
      return self.toCharUnchecked();
    } else {
      throw "invalid code point";
    }
  }
  intrinsic fun toCharUnchecked() -> char;
  intrinsic fun toLong() -> long;
  intrinsic fun toString() -> Str;

  intrinsic fun toFloat() -> float;
  intrinsic fun toDouble() -> double;

  intrinsic fun asFloat() -> float;

  intrinsic fun equals(rhs: int) -> bool;
  intrinsic fun compareTo(rhs: int) -> int;

  intrinsic fun plus(rhs: int) -> int;
  intrinsic fun minus(rhs: int) -> int;
  intrinsic fun times(rhs: int) -> int;
  intrinsic fun div(rhs: int) -> int;
  intrinsic fun mod(rhs: int) -> int;

  intrinsic fun bitwiseOr(rhs: int) -> int;
  intrinsic fun bitwiseAnd(rhs: int) -> int;
  intrinsic fun bitwiseXor(rhs: int) -> int;

  intrinsic fun shiftLeft(rhs: int) -> int;
  intrinsic fun shiftRight(rhs: int) -> int;
  intrinsic fun unsignedShiftRight(rhs: int) -> int;

  intrinsic fun unaryPlus() -> int;
  intrinsic fun unaryMinus() -> int;
  intrinsic fun not() -> int;

  fun abs() -> int {
    if self >= 0 {
      return self;
    } else {
      return -self;
    }
  }

  static fun min(lhs: int, rhs: int) -> int {
    if lhs < rhs {
      return lhs;
    } else {
      return rhs;
    }
  }

  static fun max(lhs: int, rhs: int) -> int {
    if lhs < rhs {
      return rhs;
    } else {
      return lhs;
    }
  }

  static fun max_value() -> int {
    return 2147483647;
  }

  static fun min_value() -> int {
    return -2147483648;
  }
}

intrinsic class long {
  intrinsic fun toByte() -> byte;
  fun toChar() throws -> char {
    if self >= 0L && self <= 0x10FFFFL && (self < 0xD800L || self > 0xDFFFL) {
      return self.toCharUnchecked();
    } else {
      throw "invalid code point";
    }
  }
  intrinsic fun toCharUnchecked() -> char;
  intrinsic fun toInt() -> int;
  intrinsic fun toString() -> Str;

  intrinsic fun toFloat() -> float;
  intrinsic fun toDouble() -> double;

  intrinsic fun asDouble() -> double;

  intrinsic fun equals(rhs: long) -> bool;
  intrinsic fun compareTo(rhs: long) -> int;

  intrinsic fun plus(rhs: long) -> long;
  intrinsic fun minus(rhs: long) -> long;
  intrinsic fun times(rhs: long) -> long;
  intrinsic fun div(rhs: long) -> long;
  intrinsic fun mod(rhs: long) -> long;

  intrinsic fun bitwiseOr(rhs: long) -> long;
  intrinsic fun bitwiseAnd(rhs: long) -> long;
  intrinsic fun bitwiseXor(rhs: long) -> long;

  intrinsic fun shiftLeft(rhs: long) -> long;
  intrinsic fun shiftRight(rhs: long) -> long;
  intrinsic fun unsignedShiftRight(rhs: long) -> long;

  intrinsic fun unaryPlus() -> long;
  intrinsic fun unaryMinus() -> long;
  intrinsic fun not() -> long;

  static fun max_value() -> long {
    return 9223372036854775807L;
  }

  static fun min_value() -> long {
    return -9223372036854775808L;
  }

  static fun min(lhs: long, rhs: long) -> long {
    if lhs < rhs {
      return lhs;
    } else {
      return rhs;
    }
  }

  static fun max(lhs: long, rhs: long) -> long {
    if lhs < rhs {
      return rhs;
    } else {
      return lhs;
    }
  }
}

intrinsic class float {
  intrinsic fun toInt() -> int;
  intrinsic fun toLong() -> long;
  intrinsic fun toDouble() -> double;
  intrinsic fun toString() -> Str;

  intrinsic fun asInt() -> int;

  intrinsic fun equals(rhs: float) -> bool;
  intrinsic fun compareTo(rhs: float) -> int;

  intrinsic fun plus(rhs: float) -> float;
  intrinsic fun minus(rhs: float) -> float;
  intrinsic fun times(rhs: float) -> float;
  intrinsic fun div(rhs: float) -> float;

  intrinsic fun unaryPlus() -> float;
  intrinsic fun unaryMinus() -> float;

  intrinsic fun isNan() -> bool;
  intrinsic fun sqrt() -> float;
}

intrinsic class double {
  intrinsic fun toInt() -> int;
  intrinsic fun toLong() -> long;
  intrinsic fun toFloat() -> float;
  intrinsic fun toString() -> Str;

  intrinsic fun asLong() -> long;

  intrinsic fun equals(rhs: double) -> bool;
  intrinsic fun compareTo(rhs: double) -> int;

  intrinsic fun plus(rhs: double) -> double;
  intrinsic fun minus(rhs: double) -> double;
  intrinsic fun times(rhs: double) -> double;
  intrinsic fun div(rhs: double) -> double;

  intrinsic fun unaryPlus() -> double;
  intrinsic fun unaryMinus() -> double;

  intrinsic fun isNan() -> bool;
  intrinsic fun sqrt() -> double;
}

class Object

intrinsic class Array<T> {
  init() {}
  init(len: int) {}
  init(len: int, value: T) {
    var i = 0;

    while i < len {
      self[i] = value;
      i = i + 1;
    }
  }

  intrinsic fun len() -> int;
  intrinsic fun get(idx: int) -> T;
  intrinsic fun set(idx: int, val: T);

  fun contains(value: T /* : Equals*/) -> bool {
    var i = 0;

    while i < self.len() {
      let x = self[i];
      if /*x.equals(value) ||*/ x === value {
        return true;
      }
      i = i + 1;
    }

    return false;
  }

  fun has(value: T) -> bool {
    var i = 0;

    while i < self.len() {
      if self[i] === value {
        return true;
      }
      i = i + 1;
    }

    return false;
  }
}

fun arraycopy<T>(src: Array<T>, srcPos: int, dest: Array<T>, destPos: int, len: int) {
  var i = 0;

  while i < len {
    dest[destPos+i] = src[srcPos+i];
    i = i + 1;
  }
}

trait Equals {
  fun equals(other: Self) -> bool;
}

impl Equals for int {
  intrinsic fun equals(other: int) -> bool;
}

trait Comparable {
  fun compareTo(other: Self) -> int;
}

impl Comparable for int {
  intrinsic fun compareTo(other: int) -> int;
}

fun bubbleSort<T: Comparable>(array: Array<T>) {
  let len = array.len();
  var swapped = true;

  while swapped {
    swapped = false;

    var i = 1;

    while i < len {
      if array[i-1].compareTo(array[i]) > 0 {
        let temp = array[i-1];
        array[i-1] = array[i];
        array[i] = temp;

        swapped = true;
      }

      i = i + 1;
    }
  }

}

intrinsic fun defaultValue<T>() -> T;

intrinsic fun loadFunction(name: Str) -> long;
intrinsic fun call0(fct: long) -> long;
intrinsic fun call1(fct: long, arg0: long) -> long;
intrinsic fun call2(fct: long, arg0: long, arg1: long) -> long;
intrinsic fun call3(fct: long, arg0: long, arg1: long, arg2: long) -> long;

intrinsic fun native_malloc(size: long) -> long;
intrinsic fun native_free(address: long);
intrinsic fun set_uint8(address: long, val: byte);

fun native_string(val: Str) -> long {
  var i = 0;
  let len = val.len();

  let ptr = native_malloc(len.toLong()+1L);

  while i < len {
    set_uint8(ptr+i.toLong(), val.getByte(i));
    i = i + 1;
  }

  set_uint8(ptr+len.toLong(), 0Y);

  return ptr;
}

fun getpid() -> int {
  let fct = loadFunction("getpid");
  return call0(fct).toInt();
}

fun getppid() -> int {
  let fct = loadFunction("getppid");
  return call0(fct).toInt();
}

intrinsic fun sleep(seconds: int);

class Exception {
  var msg: Str = nil;
  var backtrace: Array<int> = nil;
  var elements: Array<StackTraceElement> = nil;

  init(msg: Str) {
    self.retrieveStackTrace();
    self.msg = msg;
  }

  init() {
    self.retrieveStackTrace();
  }

  fun getStackTrace() -> Array<StackTraceElement> {
    if self.elements !== nil {
      return self.elements;
    }

    if self.backtrace === nil {
      self.elements = Array::<StackTraceElement>();
      return self.elements;
    }

    var i = 0;
    let len = self.backtrace.len() / 2;
    self.elements = Array::<StackTraceElement>(len);

    while i < len {
      self.elements[i] = self.getStackTraceElement(i);
      i = i + 1;
    }

    return self.elements;
  }

  fun printStackTrace() {
    if self.msg !== nil {
      println("Exception: " + self.msg);
    } else {
      println("Exception");
    }

    let x = self.getStackTrace();

    var i = 0;

    while i < x.len() {
      println(i.toString() + ": " + x[i].toString());
      i = i + 1;
    }
  }

  intrinsic fun retrieveStackTrace();
  intrinsic fun getStackTraceElement(idx: int) -> StackTraceElement;
}

class StackTraceElement(let name: Str, let line: int) {
  fun toString() -> Str {
    return self.name + ": " + self.line.toString();
  }
}

class IntRange(let lower: int, let upper: int) {
  fun makeIterator() -> IntRangeIter {
    return IntRangeIter(self);
  }
}

fun range(lower: int, upper: int) -> IntRange {
  return IntRange(lower, upper);
}

trait Iterator {
  fun hasNext() -> bool;
  fun next() -> int;
}

class IntRangeIter(let range: IntRange) {
  var value: int = range.lower;
}

impl Iterator for IntRangeIter {
  fun hasNext() -> bool {
    return self.value < self.range.upper;
  }

  fun next() -> int {
    let cur = self.value;
    self.value = cur + 1;
    return cur;
  }
}

open abstract class Thread {
  intrinsic fun start();

  abstract fun run();
}

